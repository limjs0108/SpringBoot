프레임워크란?
	뼈대나 근간을 이루는 코드들의 묶음.
	개발자는 각 개개인의 능력차이가 큰 직종이고, 개발자 구성에 따라 프로젝트 결과 역시
	큰 차이를 낳는다. 이런 상황을 극복하기 위한 코드의 결과물이 바로 프레임워크이다.
	프로그램의 기본 흐름이나 구조를 정하고 모든 팀원이 이 구조에 자신의 코드를 추가하는 방식으로
	개발하게 된다. 

프레임워크의 장점
	개발에 필요한 구조를 이미 코드로 만들어 놓았기 때문에, 실력이 부족한 개발자라 하더라도
	반쯤 완성한 상태에서 필요한 부분을 조립하는 형태의 개발이 가능하다.
	회사 입장에서는 프레임워크를 사용하면 일정한 품질이 보장되는 결과물을 얻을 수 있고, 개발자
	입장에서는 완성된 구조에 자신이 맡은 코드를 개발해서 넣기 때문에 개발 시간을 단축할 수 있다.
	
스프링 프레임워크란?
	경량 프레임워크(light-weight)
	예전 프레임워크는 다양한 경우를 처리할 수 있는 다양한 기능을 가지도록 만들다 보니
	하나의 기능을 위해서 너무 많은 구조가 필요했다.
	기술이 너무나 복잡하고 방대했기 때문에, 전체를 이해하고 개발하기에는 어려움이 많았다.
	그래서 스프링 프레임워크가 등장했고, 특정 기능을 위주로 간단한 jar 파일 등을 이용해서
	모든 개발이 가능하도록 구성되어 있다.

스프링 프레임워크의 장점
	- 복잡함에 반기를 들어서 만들어진 프레임워크
	- 프로젝트 전체 구조를 설계할 때 유용한 프레임워크
	- 다른 프레임워크의 포용(호환성이 좋다, 여러 프레임워크를 혼용해서 사용 가능)
	- 개발 생산성과 개발 도구의 지원
	
스프링 프레임워크의 특징
	- POJO 기반의 구성 (POJO - 스프링에서 자바 사용가능)
	- 의존성 주입(DI)을 통한 객체 간의 관계 구성 (알아서 의존 정의)
	- AOP(Aspect-Oriented-Programming) 지원 (주변로직에 집중안하게 해줌)
	- 편리한 MVC 구조 (프론트 컨트롤러 만들어줌)
	- WAS의 종속적이지 않은 개발 환경 (단일 테스트를 위한 서버 제공)
==============================================================
[POJO(Plain Old Java Object) 기반의 구성]
	오래된 방식의 간단한 자바 객체라는 의미이며, JAVA코드에서 일반적으로 객체를
	구성하는 방식을 스프링 프레임워크에서 그대로 사용할 수 있다는 말이다.
	(요약: 자바 사용 가능)

[의존성 주입(DI)을 통한 객체 간의 관계 구성]
	의존성(Dependency)이란 하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없다는 것을 의미한다.
	예를 들어 A 객체가 B 객체 없이 동작이 불가능한 상황을 'A'가 'B'에 의존적이다 라고 표현한다.

	주입(Injection)은 말 그대로 외부에서 밀어 넣는 것을 의미한다.
	예를 들어 필요한 객체를 외부에서 밀어 넣는 것을 의미한다.
	주입을 받는 입장에서는 어떤 객체인지 신경 쓸 필요가 없고 어떤 객체에 의존하든
	자신의 역할은 변하지 않게 된다.
	
	**의존성
   	ⓐ→→→→→→→→→→→→ⓑ
	a 객체에서 b 객체를 직접 생성	

  	 **의존성 주입
   	ⓐ→→→→???↔↔↔↔↔ⓑ 
	a는 b가 필요하다는 신호만 보내고, b 객체를 주입하는 것은 외부에서 이루어짐

	의존성 주입 방식을 사용하기 위해서는 ???라는 존재가 필요하게 된다.
	스프링 프레임워크에서는 ApplicationContext가 ???라는 존재이며, 필요한 객체들을 생성하고,
	필요한 객체들을 주입해주는 역할을 한다.
	따라서 개발자들은 기존의 프로그래밍과 달리 객체와 객체를 분리해서 생성하고, 이러한 객체들을
	엮는(wiring)작업의 형태로 개발하게 된다.

	ApplicationContext가 관리하는 객체들을 '빈(Bean)' 이라 부르고, 
	빈과 빈 사이의 의존 관계를 처리하는 방식으로, XML설정, 어노테이션 설정, JAVA 설정방식을 이용할 수 있다.
	메소드 안에서는 직접 선언(new 이용)

[AOP의 지원]
	관점 지향 프로그래밍.
	좋은 개발환경에서는 개발자가 비즈니스 로직에만 집중할 수 있게 한다.
	스프링 프레임워크는 반복적인 코드를 제거해줌으로써
	핵심 비즈니스 로직에만 집중할 수 있는 방법을 제공한다.

	보안이라 로그, 트랜잭션과 같이 비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을
	횡단 관심사(cross-concern)이라고 한다.
	스프링 프레임워크는 이러한 횡단 관심사를 분리해서 제작하는 것이 가능하고,
	횡단 관심사를 모듈(메소드)로 분리하는 프로그래밍을 AOP라고 한다.
	
	1) 핵심 비즈니스 로직에만 집중하여 코드 개발
	2) 각 프로젝트마다 다른 관심사 적용 시 코드 수정 최소화
	3) 원하는 관심사의 유지보수가 수월한 코드 구성 가능

[트랜잭션의 지원] 트랜잭션: 하나의 서비스를 사용하기 위해 묶어논 쿼리의 단위
	DB 작업시 트랜잭션 관리를 매번 상황에 맞게 코드로 작성하지 않고,
	어노테이션이나 XML로 트랜잭션 관리를 설정할 수 있다.

[단위 테스트]
	전체 Application을 실행하지 않아도 기능벌 단위 테스트가 용이하기 때문에
	버그를 줄이고 개발 시간을 단축할 수 있다.

**스프링 부트
	스프링 프레임워크를 사용함에 있어서 초기 설정 및  필요한 라이브러리에 대한 설정의 어려움이 많으며,
	시간이 너무 많이 걸리기 때문에 자동설정(AutoConfiguration)과 개발에 필요한 모든 것을 관리해주는
	스프링 부트를 선호한다. 각 코어 및 라이브러리의 버전들도 맞추어 줘야 하지만 스프링부트를 사용하면
	이러한 복잡성을 해결하기에도 좋다.
===============================================================================
IntelliJ 설치
   구글에 intellij 검색 > 다운로드 클릭 > 기타버전 클릭 > Version 2020.1.1 선택
   > Windows ZIP Archive(zip) 클릭 > resouce에 압축 해제 > bin폴더 > idea64.exe 실행
   > I confirm... 체크 > Continue > Don't Send > UI theme 선택 > Next default plugins
   > Next Featured plugins > start using intellij IDEA > Evaluate for Free > Evaluate

프로젝트 생성(Maven) (라이브러리 다운 : https://mvnrepository.com/)
	Maven은 필요한 라이브러리를 특정 문서(pom.xml)에 정의해 놓으면
	사용할 라이브러리 뿐만 아니라 해당 라이브러리가 작동하는 데에 필요한 다른
	라이브러리들까지 관리하여 네트워크를 통해서 자동으로 다운받아준다.

프로젝트 기본 경로
	1) src/main/java		: 서버단 JAVA 파일
	2) test/main/java		: 단위 테스트 JAVA 파일
	3) src/main/resources	: 설정 파일 및 뷰단
	4) resources/static		: css, js 등의 파일 경로
	5) resources/templates	: html 파일 경로
	6) pom.xml		: 라이브러리 의존성 관리
	7) application.properties	: 서버 및 DB 설정 파일
-------------------------------------------------------------------------------------------------------
Qualifier
	@Autowired를 통해 객체를 주입할 때 같은 타입의 객체가 여러 개 있다면 구분할 수 없다.
	이 때, @Qualifier를 통해 식별자를 부여하면 원하는 객체를 주입받을 수 있다.

	[1]
		@Qualifier("식별자")
		public class 클래스명 implements 인터페이스 {
			...
		}
	[2]
		@Autowired
		@Qualifier("식별자")
		private 인터페이스 객체명;


	default		다른패키지에서 접근 불가능 
	public		어떤 클래스에서도 접근 가능	
	protected	동일 패키지 클래스 or 클래스를 상속받은 다른 패키지 클래스에서 접근 가능
	private		해당 클래스에서만 접근 가능
	
	static 객체 간 공유할때 사용



